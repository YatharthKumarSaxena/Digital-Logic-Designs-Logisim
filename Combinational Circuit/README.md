# 🔗 Welcome to the Combinational_Circuit Folder!
> **I'm the README.md file of this folder, here to guide you step-by-step!** 🚀  
This folder is a part of my Digital Logic Design journey where I built and simulated various **combinational logic circuits** using Logisim.  
Each circuit here helped me strengthen my foundation in **digital systems, data manipulation, and logical decision making.**

---

## 📚 **Table of Contents**
1. [📖 Introduction](#-introduction)  
2. [📁 Folder Structure](#-folder-structure)  
3. [🧠 Concepts Built](#-concepts-built)  
4. [🔍 Circuit Categories](#-circuit-categories)  
5. [🎯 Final Takeaway](#-final-takeaway)

---

## 📖 **Introduction**
In this folder, I have simulated all essential **combinational circuits** ranging from **basic arithmetic blocks** to **multiplexers, demultiplexers, encoders, decoders, comparators**, and even **parity and code converter circuits**.

All designs were tested using **Logisim** after understanding their internal gate-level logic.  
> 💡 **Note**: Any circuit that overlaps with the Day-1 folder has been intentionally skipped here to avoid redundancy.

---

## 📁 **Folder Structure**
This folder contains a total of **30+ Logisim files**, grouped by type and function.

Here’s a breakdown of all files simulated and tested:

### 🔢 Arithmetic Circuits
- 🧮 **Full Adder**  
- 🧮 **Half Adders Using Basic Gates (AND, OR, XOR)**  
- ➖ **Full Subtractor (Using Half Subtractors)**  
- ➕ **Parallel Adder**  
- ⚡ **Adder for CLA**  
- 🔢 **BCD Adder**  
- 🔁 **4-Bit Adder Subtractor**  
- 💡 **4-Bit Carry Look Ahead Adder**  
- 💡 **Carry Look Ahead Adder**  
- 💥 **16-Bit Adder Using 4-Bit CLA**

### 📐 Comparators
- 🟰 **1-Bit Magnitude Comparator**  
- 🟰 **2-Bit Magnitude Comparator**  
- 🟰 **4-Bit Magnitude Comparator**

### 🔄 Encoders & Decoders
- 🔐 **2X1 Encoder**  
- 🔐 **4X2 Encoder**  
- 🔓 **3X8 Decoder**  
- 🔓 **4X16 Decoder Using 3X8 Decoder**

### 🔁 Multiplexers
- 🔘 **2X1 Multiplexer**  
- 🔘 **4X1 Multiplexer Using 2X1 Multiplexer**  
- 🔘 **8X1 Multiplexer Using 2X1 Multiplexer**  
- 🔘 **Quadruple 2 to 1 Line Multiplexer**

### 🔀 Demultiplexers
- 📤 **1X2 Demultiplexer**  
- 📤 **1X4 Demultiplexer Using 1X2 Demux**  
- 📤 **1X8 Demultiplexer Using 1X4 Demux**

### 🔣 Code Converters
- 🔄 **Excess-3 Code Converter (Using Parallel Adder)**  
- ✅ **Excess-3 Code Generator and Checker**

### 🔍 Parity Circuits
- 📏 **Even Parity Generator and Checker**  
- 📐 **Odd Parity Generator and Checker**

---

## 🧠 **Concepts Built**
- Truth table design and K-map optimization  
- Binary arithmetic and carry propagation  
- Modular design via cascading components (MUX, DEMUX)  
- Reusability and hierarchical circuit design  
- Parity and error-checking logic  
- Binary to BCD and code format conversions  
- Logical comparison at bit-level granularity  
- ✅ **Focused on minimizing gate-level depth** in every circuit to **reduce propagation delay**  
- 🧠 **Implemented jugaad-style low-level logic**, ensuring **same output logic** with **fewer gates and minimal delay**, especially in critical path circuits

---

## 🔍 **Circuit Categories**
To organize my learning, I divided the circuits as follows:
- **Arithmetic Circuits** – for binary calculations and logic-based math
- **Comparators** – to compare binary numbers
- **Encoders/Decoders** – to switch between binary inputs and active signals
- **Multiplexers/Demultiplexers** – to control signal routing dynamically
- **Code Converters** – for data representation and encoding
- **Parity Checkers** – for ensuring error-free data transmission

---

## 🎯 **Final Takeaway**
This folder became my **digital playground** for understanding how **combinational logic** works under the hood. From designing a full subtractor to building a 16-bit CLA, every circuit enhanced my **clarity on logic flow, signal manipulation, and circuit modularity.**

It made me realize how **simple gates**, when combined logically, can build **powerful and scalable logic blocks** for real-world systems like CPUs and memory units.

> 📌 I'm proud to say this folder marks the point where digital logic stopped being theoretical — it became real, visual, and programmable.

---

